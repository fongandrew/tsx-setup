/*
  HOC for creating a React component that automatically updates upon some set
  of subscribed data sources. Similar in concept to something react-redux but
  agnostic (and more flexible) about how we get and store state.
*/
import * as React from 'react';

// Callback function for a subscription
export type SubCb<T> = (value: T) => void;

// A subscription generated by props P that calls callback with type T
// on change. May be updated with new props.
export interface Subscription<P, T> {

  // Update the subscription with new props.
  update(props: P, cb: SubCb<T>): void;

  // Stop the current subscription
  unsubscribe(): void;

  // Last state
  state: T;
}

// Function to create subscription from props. Returns 2-tuple with initial
// value for subscription.
export type SubFn<P, T> =
  (props: P, cb: SubCb<T>) => Subscription<P, T>;

// Map between input props I to subscribeFns for output props O
export type SubFnMap<I, O> = {
  [K in keyof O]: SubFn<I, O[K]>
};

// Map between input props I to subscriptions for output props O
export type SubMap<I, O> = {
  [K in keyof O]: Subscription<I, O[K]>
};


// Base class for HOC, updates when subscription changes
abstract class SubscriberBase<I, O> extends React.Component<I, O> {

  // Active subscriptions
  protected subscriptionMap: SubMap<I, O>;

  constructor(props: I) {
    super(props);

    // Create partial objects and fill in.
    const state: Partial<O> = {};
    const subscriptionMap: Partial<SubMap<I, O>> = {};

    // Subscribe for each key
    const subscribeFnMap = this.getSubscribeFnMap();
    Object.keys(subscribeFnMap).forEach((key: keyof O) => {
      const subscription = subscribeFnMap[key](
        this.props,
        this.getCallback(key)
      );
      state[key] = subscription.state;
    });

    this.state = state as O;
    this.subscriptionMap = subscriptionMap as SubMap<I, O>;
  }

  // HOC fills this in to dictate how subscribeFnWorks
  protected abstract getSubscribeFnMap(): SubFnMap<I, O>;

  // Return callback to update a given key
  private getCallback<K extends keyof O>(key: K) {
    return ((v: O[K]) => this.setState({ [key]: v } as Pick<O, keyof O>));
  }

  // Update subscription on prop change
  componentWillReceiveProps(props: I) {
    Object.keys(this.subscriptionMap).forEach((key: keyof O) => {
      this.subscriptionMap[key].update(props, this.getCallback(key))
    });
  }

  // Update only if props or at least one key in state doesn't match
  shouldComponentUpdate(nextProps: I, nextState: O) {
    if (this.props !== nextProps) return true;
    for (let [key, value] of Object.entries(this.state)) {
      if (nextState[key as keyof O] !== value) return true;
    }
    return false;
  }

  // Unsubscribe on unmount
  componentWillUnmount() {
    Object.keys(this.subscriptionMap).forEach((key: keyof O) => {
      this.subscriptionMap[key].unsubscribe();
    });
  }
}


// Alias stateless + other components
type Component<P> = React.ComponentClass<P>|React.StatelessComponent<P>;

// HOC
export default function<I, O1, O2 = O1>(
  mapSubscribeToProps: SubFnMap<I, O1>,
  mergeProps?: (stateProps: O1, ownProps: I) => O2
    // Mix merge props with ownProps
) {
  return function(compCls: Component<O2>) {
    return class Subscriber extends SubscriberBase<I, O1> {
      getSubscribeFnMap() {
        return mapSubscribeToProps;
      }

      render() {
        return React.createElement(compCls, this.getMergedProps());
      }

      protected getMergedProps(): O2 {
        if (mergeProps) {
          return mergeProps(this.state, this.props);
        }
        return this.state as any;
      }
    }
  }
}
